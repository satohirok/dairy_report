# 達人に学ぶDB設計 メモ

## 1章:データベースを制するものはシステムを制す
* データベースを使わないシステムはこの世に存在せず、システムは基本的にデータベースに合わせて作られる。(データ中心アプローチ)
* 情報はデータ(事実)と文脈（事実からの推測、観点）を合成して生まれる。
* データベース管理システム(Oracle,MySQL,PostgreSQL,SQLServer)によって、設計が影響を受けることはない。→基礎根幹の部分を抑えることが大切。
* ソフトウェアというのは、「データの流通機構」なのでデータ設計がシステムの品質を大きく左右する。
* スキーマ(枠組み、構図)
  * ``外部スキーマ``:ユーザーから見えるデータベースのこと。(画面のユーザーインターフェイスや入力データなど)
  * ``概念スキーマ``:開発者からみたデータベースのこと。（論理設計：正規化→ER図）
  * ``内部スキーマ``:DBMSから見たデータベースのこと。(物理設計:ファイルで表現される世界)
  * 外部スキーマと内部スキーマの``2層スキーマ``では、スキーマ同士の結合度が高いので、変更に弱いシステムになってしまう。
  * 上記の2層スキーマの``緩衝材(2つのスキーマのデータ独立性を高める)``の役割として、概念スキーマが存在する。
* 演習:アプリケーション改修のタイプとコスト
  * 問題1:
  * 問題2:
 
## 2章:論理設計と物理設計（?な用語・概念が多いので後で見直し、整理）
* 論理設計
  * エンティティの抽出→エンティティの定義→正規化→ER図の作成
* 物理設計
  * サイジング
  * RAID
  * ファイルの物理配置
* バックアップ設計
* リカバリ設計

## 3章:論理設計と正規化
* テーブルは共通点を持ったレコード(同じ種類のもの)の集合のことである。
* テーブル名は英語ならば複数形/複数名詞で書くことができる。そうでなければそのテーブルにはどこか間違いがある。
* テーブルの構成要素
  * ``行と列``:テーブルにおける横と縦のデータの組のこと 
  * ``主キー``:テーブルに置いて必ず１つ存在しなければならず、かつ１つしか存在しないもの。主キーを用いることで行のレコードを一意に識別することができる。
  * RSBMのテーブルに重複行は存在することができない。
  * ``外部キー``:２つのテーブル間同士で設定するもの。2つのテーブルの結合度を高めることで、テーブルに対して``制約``を課すことができる。（参照整合性制約）
  * キーの整合性を保つためにも、キーに使用する列は必ず何らかのコードとIDといった表記体系の定まったデータを``固定長文字列``のデータ型に格納して使用する必要がある。
  * テーブルや列の名前に日本語はNG
* 正規化:データベースで保持する冗長性を排除し、一貫性と効率性を保持するためのデータ形式。
  * 冗長なデータを保持していると、更新処理のタイムラグによってデータの不整合が発生したり、そもそもデータを登録できないようなテーブルを作ってしまうことがある。
  * 正規化は１〜5まであるが、実務では３まで理解すれば十分事足りる。
  * テーブルの数が増えて、SQL文で結合を多用することになり、パフォーマンスが落ちることがある。
* 第1正規化:１つのセルの中には１つの値しか含まない。
  * セルに複数の値を許すと、主キーが各列の値を一意に決定することができなくなってしまう。
  * ``関数従属性``:２つの属性感で、片方の値を決定するともう一方の値も一意に決まる性質のこと。
* 第2正規化:部分関数従属を解消する
  * ``部分関数従属``:主キーの一部の列に対して従属する列があること。(?→確認)
  * 現実世界の実体間にある階層の差を反映させる。（例:会社情報と社員情報でテーブルを分ける→どちらかを変更、更新しても矛盾が生じない。→変更に強くなる）
  * ``結合``:分割したテーブルはINNER JOIN で元に戻すことができる。
* 第3正規化:テーブル内の推移的関数従属によるデータ登録時の不都合を解消する
  * ``推移的関数従属``:テーブル内部に存在する段階的な従属関係。
* （※第4、第５正規化については省略）
* 正規化のポイント
  * データの冗長性を排除して、更新時（update,insert）の不都合、不整合を排除するために行う。
  * 従属性（項目同士関連性）を見抜くことが可能になる。
  * テーブル同士を結合することで、いつでも非正規形に戻すことができる。
* (※正規化の問題演習が空で解けないので練習する必要があると感じた)

## 4章:ER図
* ``ER図``:正規化によって分割されたテーブル同士の関係を分かりやすくするための図
* ER図を記述する際はまず``主キー``に着目する。共通の主キーがあるということはテーブル同士に関連性があるということ。
* （※ER図の書き方は文章よりも図でアウトプットした方が身につくので、Qiitaで記述することにする）

## 5章:論理設計とパフォーマンス
* 正規化されたテーブルから目的にデータを抽出(select)する場合、join(結合)が必要になるため、多用するとSQLの速度が悪化することがある。
* 更新処理の場合は更新テーブルがのレコードが１つに限定されるため、負荷は少なくなる。
* 非正規化は基本的にしない。切羽詰まった状況の時にだけする最終手段と考えておく。

## 6章:データベースとパフォーマンス
* ``インデックス``:特定のレコードを狙い撃ちしてアクセルするための索引のような役割を果たすもの
* ``統計情報``:ユーザーが目的のデータに最短経路で辿りつくための地図のようなもの。
* インデックス設計
  * インデックス設計はSQLのパフォーマンス改善のために非常にポピュラーな手段
  * インデックスを導入する上で、その存在を意識しなくてもよく、データの中身が影響を受けることもない（透過的）
  * インデックスには色々あるが、まずはB-treeインデックスから覚えていく。
  * B-treeインデックス特徴
    * 均一性:どんなキー値を使っても、常にルートまでの距離が一定になるため、探索を同じ計算量で行える。
    * 持続性:テーブルのデータ量が増えても、検索や更新にかかる時間はほとんど増えない。
    * 非等値性:等号(=)の検索のみならず、不等号(<,>,<=,>=)やBETWEENといった範囲検索の条件に関しても高速化を可能にする。
    * 親ソート性:??
  * B-treeインデックスの設計方法
    * インデックスの効果を発揮できるという観点から、テーブル規模が大きい
    * カーディナリティ:特定の列の値がどれくらいの種類を持つかということを表す概念。列が多いほどインデックスの効果を発揮できる。
    * 特定の値にデータが集中しているよりも、平均的に分散しているのがベスト。
* 統計情報　→？な箇所や語句が多い、、、
  * オプティマイザ
 
## 7章:論理設計のバッドノウハウ
* システムの心臓であるDBの設計におけるバッドノウハウは、システム全体としての品質を致命的なレベルで損なってしまう。
* 戦略(設計)の失敗を戦術(プログラミング)でとり戻ることはできない。
* 非スカラ値(第1正規形未満、１つのカラムに2つ以上の値が入っている)
  * 配列型を利用すると、非スカラ値のテーブルを作成することが可能。
  * 基本的に配列形は利用せず、第1正規形を守る。
  * 意味的に分割できる限り、できるだけ意味を壊さない程度に分割することを原則とする。(分割されたものを結合するのは容易だが、結合されたものを後から分割することはできないから)
* ダブルミーニング:1つの列で2つの意味を持たせてしまうこと
  * テーブルの列は変数ではないので、一度意味を決めたら変更することはできない。
  * 別の情報を格納したい場合は列を増やすことで対応する。１つの列に詰め込もうとしない。
* 単一参照テーブル
  * テーブルを1つにまとめると、ER図やスキーマがシンプルになる、コード検索のSQLを共通化できるといったメリットがある。
  * しかし、ER図はスッキリするが正確さを欠いて、可読性を下げる、レコード数が多くなり検索パフォーマンスを下げるなどデメリットの方か多い。
  * 上記より、テーブルは正規化によって分割することが原則となる。
* テーブル分割
  * 水平分割:レコード単位でテーブルを分割する手段。アクセスするデータ量を分割することができるので、パフォーマンスの改善につながる。
    * しかし、``分割する意味的理由がない``,``拡張性に乏しい``などと言った点から、RDBでは原則禁止されている。
  * 集約:テーブル分割の代替案
    * 列の絞り込み:頻繁に使用する列を絞り込んだテーブル(``データマート``)を作成する。オリジナルのテーブルとのデータの同期が必要になってくる。
    * サマリーテーブル:集約関数を用いたSLECT文によって、データの集約することで作成されたテーブルのこと。
* ダブルマスタ:同じ役割を果たすマスタテーブルが2つ存在する状態。
  * タブルマスタはSQLを複雑にし、パフォーマンスを悪化させる。
  * ダブルマスタはシステム統廃合の過程で起きることが多い。
## 8章:論理設計のグレーノウハウ
* 代理キー

